Question: In each of 404 samples, do PRDM9-bound ATAC-seq peaks contain more somatic mutations than expected by chance?
# Brief Problem Description:
The binding of PRDM9 will introduce genetic variants in meiotic recombination. PRDM9 normally just has expression in testis, but it is also found to express in cancer cells. However, how does PRDM9 work in cancer cells? Is there a statistically significant association between PRDM9 binding regions and somatic mutations in cancer cells?
# Datasets: two region sets
## Set A: PRDM9-bound peaks in 404 samples
410 tumor samples from 404 donors, after renaming just 404 samples left.
### rename files
**before renaming**

*<cancerType#>_<stanfordUUID#>_<batch#>_<sample#>_<libraryID#>_<bioRep#>_<techRep#><pool#>*

TGCT_1577A485_E047_42CF_8703_42A69E1AED1A_X038_S09_L090_B1_T2_PMRG

- <stanfordUUID#> - 1577A485-E047-42CF-8703-42A69E1AED1A - This corresponds to a unique 36-character ID given to each tissue fragment. This is not the same as the 36-character TCGA sample_id/case_id. Hyphens were replaced by underscores.

**after renaming**

Case_ID
TCGA-XE-AANI-01A
## SetB: somatic mutation (SNPs and small INDELs)
### download and check files
```bash
wget https://gdc.xenahubs.net/download/GDC-PANCAN.muse_snv.tsv.gz
gzip -d GDC-PANCAN.muse_snv.tsv.gz 
wc -l GDC-PANCAN.muse_snv.tsv # 2684789
awk '{if($4 == $5){print $0}}' GDC-PANCAN.muse_snv.tsv | wc -l # 2684788
awk '{if($4 != $5){print $0}}' GDC-PANCAN.muse_snv.tsv | wc -l # 1

wget https://gdc.xenahubs.net/download/GDC-PANCAN.mutect2_snv.tsv.gz
gzip -d GDC-PANCAN.mutect2_snv.tsv.gz
wc -l GDC-PANCAN.mutect2_snv.tsv # 3175930
awk '{if($4 == $5){print $0}}' GDC-PANCAN.mutect2_snv.tsv | wc -l # 3068128
awk '{if($4 != $5){print $0}}' GDC-PANCAN.mutect2_snv.tsv | wc -l # 107802

wget https://gdc.xenahubs.net/download/GDC-PANCAN.somaticsniper_snv.tsv.gz
gzip -d GDC-PANCAN.somaticsniper_snv.tsv.gz
wc -l GDC-PANCAN.somaticsniper_snv.tsv # 2202278
awk '{if($4 == $5){print $0}}' GDC-PANCAN.somaticsniper_snv.tsv | wc -l # 2202277
awk '{if($4 != $5){print $0}}' GDC-PANCAN.somaticsniper_snv.tsv | wc -l # 1

wget https://gdc.xenahubs.net/download/GDC-PANCAN.varscan2_snv.tsv.gz
gzip -d GDC-PANCAN.varscan2_snv.tsv.gz
wc -l GDC-PANCAN.varscan2_snv.tsv # 2854562 
awk '{if($4 == $5){print $0}}' GDC-PANCAN.varscan2_snv.tsv | wc -l # 2776104
awk '{if($4 != $5){print $0}}' GDC-PANCAN.varscan2_snv.tsv | wc -l # 78458
```
### choose the most appropriate dataset 
> There is currently no scientific consensus on the best variant calling pipeline so the investigator is responsible for choosing the pipeline(s) most appropriate for the data. 

**check the overlap between different datasets**
```bash
for file in $(ls ./*_snv.tsv); do sort -k3,3 -k4,4n $file | awk '{FS=OFS="\t"}}' > ./${file}.sorted; done
bedtools intersect -a GDC-PANCAN.muse_snv.tsv.sorted -b GDC-PANCAN.mutect2_snv.tsv.sorted -v | wc -l # 157126
bedtools intersect -a GDC-PANCAN.muse_snv.tsv.sorted -b GDC-PANCAN.somaticsniper_snv.tsv.sorted -v | wc -l # 453661
bedtools intersect -a GDC-PANCAN.muse_snv.tsv.sorted -b GDC-PANCAN.varscan2_snv.tsv.sorted -v | wc -l # 191575

bedtools intersect -a GDC-PANCAN.somaticsniper_snv.tsv.sorted -b GDC-PANCAN.muse_snv.tsv.sorted -v | wc -l # 72598
bedtools intersect -a GDC-PANCAN.somaticsniper_snv.tsv.sorted -b GDC-PANCAN.mutect2_snv.tsv.sorted -v | wc -l # 116359
bedtools intersect -a GDC-PANCAN.somaticsniper_snv.tsv.sorted -b GDC-PANCAN.varscan2_snv.tsv.sorted -v | wc -l # 28011

bedtools intersect -a GDC-PANCAN.varscan2_snv.tsv.sorted -b GDC-PANCAN.muse_snv.tsv.sorted -v | wc -l # 316740
bedtools intersect -a GDC-PANCAN.varscan2_snv.tsv.sorted -b GDC-PANCAN.mutect2_snv.tsv.sorted -v | wc -l # 173890
bedtools intersect -a GDC-PANCAN.varscan2_snv.tsv.sorted -b GDC-PANCAN.somaticsniper_snv.tsv.sorted -v | wc -l # 528596
```
`GDC-PANCAN.mutect2_snv.tsv` has most mutations and relatively larger overlap with other datasets.

**check pipeline**

We have somatic mutations called by 4 separate pipelines: MuSE, MuTect2, SomaticSniper and VarScan2.

> The `MuTect2` pipeline employs a "Panel of Normals" to identify additional germline mutations. This panel is generated using TCGA blood normal genomes from thousands of individuals that were curated and confidently assessed to be cancer-free. This method allows for a higher level of confidence to be assigned to somatic variants that were called by the `MuTect2` pipeline.

**Therefore, we choose the dataset generated by `MuTect2` pipeline.**
### save snv files as RDS format
```r
# mutect2_snv
mutect2_snv <- read.delim("/exports/eddie/scratch/s1949868/SNPsAndSmallINDELs/GDC-PANCAN.mutect2_snv.tsv",header = TRUE,sep = "\t")
mutect2_snv$Sample_ID=as.character(mutect2_snv$Sample_ID)
mutect2_snv$chrom=as.character(mutect2_snv$chrom)
saveRDS(object = mutect2_snv, file = "mutect2_snv.rds")
```
### choose samples with more mutations
```r
# count somatic mutations of a sample
num <- nrow(mutect2_snv[mutect2_snv$Sample_ID==ID,])

# get the number of overlaps between peaks and mutations for a sample
mutations <- toGRanges(mutect2_snv[mutect2_snv$Sample_ID==ID,c(3,4,5)])
peaks <- toGRanges(paste0("/exports/eddie/scratch/s1949868/PRDM9BoundPeaks_410_Case_ID/",ID,"_PRDM9_bound_peaks.bed"))
numOverlaps <- numOverlaps(A=peaks, B=mutations, count.once=TRUE)
```
```bash
# sort samples by overlap number
grep -v "sampleID" MutNumber.txt | awk '{FS=OFS="\t";if($3!=0 && $4!=0){print $0}}'> MutNumber.noZero.txt
sort -k4,4nr MutNumber.noZero.txt > MutNumber.noZero.sorted.txt
head MutNumber.noZero.sorted.txt
```
	TCGA-AA-A010-01A        COAD    10239   153
	TCGA-NH-A5IV-01A        COAD    3753    111
	TCGA-AP-A051-01A        UCEC    12041   81
	TCGA-F7-A624-01A        HNSC    4050    70
	TCGA-AA-A01R-01A        COAD    2522    61
	TCGA-AD-6889-01A        COAD    2685    60
	TCGA-D9-A6EC-06A        SKCM    5641    56
	TCGA-AA-A022-01A        COAD    2276    43
	TCGA-D3-A8GM-06A        SKCM    5137    43
	TCGA-85-A4CL-01A        LUSC    989     39
# Analyze the association of two sets based on permutation tests
The idea of the test is to randomly move PRDM9-bound peaks along the genome and count how many of them overlap with at least one somatic mutation. 
## randomization function
creates a new set of regions that is random with respect to our evaluation function but takes into account the specificities of our original region set. many randomization functions provided by regioneR accept a mask, indicating where a random region cannot be placed.
`randomizeRegions`: given a RS, a genome and an optional mask, returns a new RS with the same number of regions and of the same width as the original ones but randomly placed along the non-masked parts of the genome. 
genome
mask
## evaluation function
`numOverlaps` function: given two RS, returns the number of overlaps between them.
If we do this many times we will build a distribution of the evaluation obtained from random RS and so, we can compare our initial evaluation with those obtained randomly and determine whether it is plausible that our original evaluation was obtained by chance or not. Actually, just counting the number of times the evaluation of the random RS is higher (or lower) than our original evaluation, we can compute the probability of seeing our original evaluation by chance, and that value is exactly the p-value of the permutation test.

Moving the regions in A produces a drop in the z-scores shows that the association is dependant on the exact position of the regions and is not a regional effect.



reproducible
textual output
plot

```r
set.seed(12345)
pt <- overlapPermTest(cpgHMM_2K, promoters, ntimes=1000, genome="hg19", count.once=TRUE, force.parallel=FALSE)
pt_Rad21_5k_vs_Ctcf <- permTest(A=HepG2_Rad21_5K, B=HepG2_Ctcf, ntimes=1000,
+                                   randomize.function=circularRandomizeRegions,
+                                   evaluate.function=numOverlaps, count.once=TRUE,
+                                   genome="hg19", mc.set.seed=FALSE, mc.cores=4)

```
```r
# remove the promoters and CpG islands in non-canonical chromosomes
cpgHMM <- filterChromosomes(cpgHMM, organism="hg", chr.type="canonical") promoters <- filterChromosomes(promoters, organism="hg", chr.type="canonical")
# count a peak only once even if it overlaps 2 or more mutations, we use the parameter `count.once=TRUE`,
pt <- overlapPermTest(cpgHMM_2K, promoters, ntimes=1000, genome="hg19", count.once=TRUE, force.parallel=FALSE)
png("pt.png",width = 960,height = 960)
plot(pt)
dev.off()
lz_Rad21_vs_Ctcf_1 <- localZScore(A=HepG2_Rad21_5K, B=HepG2_Ctcf, pt=pt_Rad21_5k_vs_Ctcf, window=1000, step=50, count.once=TRUE)

```
```r
pt <- permTest(A=peaks, B=mutations, ntimes=1000, randomize.function=circularRandomizeRegions, evaluate.function=numOverlaps, count.once=TRUE, genome="hg38", mc.cores=4, mc.set.seed=FALSE)
```
`numOverlaps` the evaluation function
`count.once` each region in A is counted at most once.
`circularRandomizeRegions` keep the internal structure of the region set (won’t change the distance between adjacent regions), faster than `randomizeRegions`
`mc.cores=4` use 4 processor cores
`mc.set.seed=FALSE` to ensure a reproducible result.
should pass the name of the parameters passed to `permTest`

To further investigate the nature of the associations, we will use the `localZscore` function, that will move the original regions around and see the effect in the z-score. In this case, we will start with a window of 1000bp and a step of 50bp. To run the local z-score analysis, we need to give it the original region set A, the results of the permutation test and the additional parameters needed by the evaluation function, in this case, `B=HepG2_Ctcf` and `count.once=TRUE`.

614 out of 2000 CpG islands overlap at least one promoter while a mean of only 79.087 islands overlapped a promoter in the randomized region sets. In the plot we can see in grey the distribution of the evaluation of the randomized regions, in green the evaluation of the original region set (in this case, the 614 CpG islands that overlap at least one promoter), and in red the significance limit. The the high z-score and the plot make evident the extreme significance of the association tested.


We can see a visual representation of the results of the test. In grey the number of overlaps of the randomized regions with B, clustering around the black bar that represents the mean and in green the number of overlaps of the original region set A, which is much larger than expected. The red line denotes the significance limit.

evaluation function (which type of association to be tested)
randomization function (how to randomize regions in a set)
test (performing the permutation tests and producing the statistical evaluation of the results.)

In addition, we can test if the association between the two region sets is highly dependant on their exact position. To do that, we can use the `localZScore` function.？
**Evaluate the association between PRDM9 binding regions and mutational regions in cancer:** Permutation tests through regioneR package will be performed to assess the overlap between the PRDM9 binding regions and mutations (SNPs, indels and structural variant breakpoints) (Gel _et al._, 2016). In each of the 404 samples, the PRDM9 binding regions will be tested with SNPs plus indels and structural variant breakpoints, respectively. The permutation test includes two steps: randomize the regions and evaluate the association. The randomization function circularRandomizeRegions will be selected for circular permutation and the evaluation function numOverlaps will assess the number of overlaps by p-value. There is a backup plan for structural variants: if the structural variants are low in number, we will use merged pan-cancer PRDM9 binding regions and merged pan-cancer structural variants to do permutation test.

mutations (SNPs, indels and structural variant breakpoints)





# Randomization strategy 
maintains the order and distance of the regions, while changing their position in the chromosome.



evaluating the original RS, creating a number of randomizations and evaluating them and nally computing the p-value and z-score.
`ntimes` to specify the number of randomizations, `verbose` to toggle the drawing of a progress bar, `force.parallel` to force or forbid the use of multiple cores to run the analysis…- and it also accepts any additional parameter required by the randomization function (usually a genome and a mask) or the evaluation function.
creates a new set of regions that is random with respect to our evaluation function but takes into account the specificities of our original region set.
For example, if our original RS comes from an NGS experiment, all of its regions would lie in mappable parts of the genome and wouldn’t make any sense to randomize a region into a centromere or any other non-mappable part of the genome. To help with that, many randomization functions provided by regioneR accept a mask, indicating where a random region cannot be placed.
`randomizeRegions`: given a RS, a genome and an optional mask, returns a new RS with the same number of regions and of the same width as the original ones but randomly placed along the non-masked parts of the genome.
Actually, just counting the number of times the evaluation of the random RS is higher (or lower) than our original evaluation, we can compute the probability of seeing our original evaluation by chance, and that value is exactly the p-value of the permutation test. In addition, we compute the z-score which is the distance between the evaluation of the original RS and the mean of the random evaluations divided by the standard deviation of the random evaluations. The z-score, although not directly comparable, can help in assessing “the strength” of the evaluation.
# Evaluation function
`numOverlaps` function: given two RS, returns the number of overlaps between two sets
in our case we can compute the number of PRDM9-bound ATAC-seq peaks overlapping somatic mutations.
# Reference
[https://bioconductor.org/packages/3.11/bioc/vignettes/regioneR/inst/doc/regioneR.html](https://bioconductor.org/packages/3.11/bioc/vignettes/regioneR/inst/doc/regioneR.html)
[https://bernatgel.github.io/karyoploter_tutorial/Tutorial/PlotRegions/PlotRegions.html](https://bernatgel.github.io/karyoploter_tutorial/Tutorial/PlotRegions/PlotRegions.html)

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTg0OTg1ODI4NiwxOTM4ODIyMzAxLC0xMD
g1MTcwMzA2LDM3NTIwOTU2MSw1OTA1MTMwOTAsOTkwMTk2MTIw
LDE3ODgzODQ1OTksLTE3OTU4Njk2MTAsLTc5MjQ2ODM1NywxMj
EyNTY3MjQwLC0xMDI4ODI2MjksLTUyNjUwOTQyMCwxNTIzMjU3
MTkxLC02MDgyMzI4OTQsMTQ4NTQ3NzU0NCw2MTQ0NTkwNDksMT
YxMDAzNTY2NywxMjQ5MDA2MDY5LDE2OTgwNTMyMzcsLTE0MTY4
Mzg3MzhdfQ==
-->